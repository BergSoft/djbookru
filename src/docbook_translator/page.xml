<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN"
"http://www.oasis-open.org/docbook/xml/4.2/docbookx.dtd"
[
<!ENTITY BASEID "djangobook.chap03">
]>

<chapter lang="ru" id="&BASEID;">

  <title id="&BASEID;.title">
    Представления и привязки URL
  </title>

  <para>
    Перевод c Попов Руслан &lt;ruslan.popov - gmail&gt;
  </para>

  <para>
    В предыдущей главе мы объяснили как настроить проект и запустить
    сервер разработки. В этой главе вы изучите основы создания
    динамических страниц с помощью Django.
  </para>

  <section id="&BASEID;.first-page">

    <title id="&BASEID;.first-page.title">
      Ваша первая страница на Django: Привет, Мир
    </title>

    <para>
      В качестве вашего первого задания, давайте создадим страницу,
      которая будет выводить знаменитое сообщение: <quote>Здравствуй,
      Мир</quote>.
    </para>

    <para>
      Если бы вы создавали обычную страницу с текстом
      <quote>Здравствуй, Мир</quote> без использования Django, то
      достаточно было бы создать файл с таким текстом, дать ему имя
      <filename>hello.html</filename> и загрузить в каталог на веб
      сервере. Следует отметить, что в этом случае, вы определяете два
      ключевых параметра страницы: её содержимое (строка
      <quote>Здравствуй, Мир</quote>) и её URL (<ulink
      url="http://www.example.com/hello.html/"/>).
    </para>

    <para>
      Используя Django, вы указываете те же самые параметры, но другим
      способом. Содержимое страницы создаётся с помощью
      <emphasis>функции представления</emphasis>, а URL определяется в
      <emphasis>файле привязок URL</emphasis>. Сначала давайте напишем
      нашу функцию представления.
    </para>

    <section id="&BASEID;.first-page.first-view">

      <title id="&BASEID;.first-page.first-view.title">
        Ваше первое представление
      </title>

      <para>
        Внутри каталога <filename>mysite</filename>, который был
        создан с помощью команды <command>django-admin.py
        startproject</command> в предыдущей главе, создайте пустой
        файл с именем <filename>views.py</filename>. Этот файл будет
        содержать представления, описываемые в данной главе. Следует
        отметить, что нет ничего особенного в выбранном нами имени
        файла. Django нет никакой разницы как он называется и вы
        убедитесь в этом сами. Но, назвать так файл - это
        хорошая идея, другим разработчикам будет проще ориентироваться
        в вашем коде.
      </para>

      <para>
        Наше представление простое, оно состоит из кода функции и
        оператора импорта. Вот содержимое файла
        <filename>views.py</filename>:
        <screen>
          <![CDATA[
# -*- coding: utf-8 -*-
from django.http import HttpResponse

def hello(request):
    return HttpResponse("Здравствуй, Мир")
          ]]>
        </screen>
      </para>

      <para>
        Пройдёмся по коду, строчка за строчкой:
        <itemizedlist>
          <listitem>
            <para>
              Сначала мы импортируем класс
              <classname>HttpResponse</classname>, который определён в
              модуле <token>django.http</token>. Нам необходимо
              импортировать этот класс, так как он используется в
              нашем коде.
            </para>
          </listitem>

          <listitem>
            <para>
              Затем, мы определяем функцию <function>hello</function>
              - функцию представления.
            </para>

            <para>
              Каждая функция представления принимает как минимум один
              параметр, который для удобства называют
              <token>request</token>. Это объект, который содержит
              информацию об обрабатываемом запросе, который привёл к
              вызову данной функции представления. Объект является
              экземпляром класса
              <classname>django.http.HttpRequest</classname>. В данном
              примере, мы ничего не делаем с этим объектом, но не
              смотря ни на что, он всегда должен быть первым
              параметром функции представления.
            </para>

            <para>
              Следует отметить, что имя функции представления несёт
              только смысловую нагрузку для разработчика. Мы дали
              функции имя <function>hello</function>, так как такое
              имя явно определяет назначение функции, но мы могли бы
              её назвать и так
              <function>hello_wonderful_beautiful_world</function> и
              так далее.  Следующий раздел, <quote><xref
              linkend="&BASEID;.first-page.first-urls"
              endterm="&BASEID;.first-page.first-urls.title"/></quote>,
              проливает свет на то, как Django находит функцию.
            </para>
          </listitem>

          <listitem>
            <para>
              Функция является однострочной. Она просто возвращает
              <classname>HttpResponse</classname> объект, который был
              создан с текстом <quote>Здравствуй, мир</quote>.
            </para>
          </listitem>
        </itemizedlist>
        Вот и все.
      </para>

      <para>
        Основная идея в том, что представление является функцией языка
        Python, которая принимает <classname>HttpRequest</classname> в
        качестве первого параметра и возвращает экземпляр
        <classname>HttpResponse</classname>. Для того, чтобы функция
        языка Python стала функцией представления Django, он должен
        соответствовать этим двум правилам. Есть исключения из этих
        правил, но мы рассмотрим их позже.
      </para>

    </section>
  </section>
  
  <section id="&BASEID;.second-view">

    <title id="&BASEID;.second-view.title">
      Ваше второе представление: Динамическое содержимое
    </title>

    <para>
      Наше представление <quote>Здравствуй, Мир</quote> было
      поучительным с точки зрения основ использования Django, но оно
      не было примером <emphasis>динамического</emphasis> создания
      страниц, так как содержимое страницы не изменялось. Каждый раз,
      посещая эту страницу, вы видели одно и тоже. То же самое
      достигается и с помощью статического HTML файла.
    </para>

    <para>
      Для нашего второго представления давайте создадим что-нибудь
      динамическое - страницу, которая будет отображать текущую
      дату и время. Это хороший и одновременно простой пример, потому
      что он не требует ни использования базы данных, ни обработки
      пользовательского ввода - просто выводит значение
      даты/времени, ориентируясь на внутренние часы сервера. Это лишь
      чуть более интересно, чем предыдущее представление, но оно
      продемонстрирует несколько новых концепций.
    </para>

    <para>
      Данное представление должно делать две вещи: вычислять текущую
      дату и время и возвращать <classname>HttpResponse</classname>,
      содержащий это значение. Если у вас был опыт работы с Python, вы
      знаете, что он предоставляет модуль <token>datetime</token> для
      работы с датой и временем. Покажем как его можно использовать:
      <screen>
        <![CDATA[
>>> import datetime
>>> now = datetime.datetime.now()
>>> now
datetime.datetime(2008, 12, 13, 14, 9, 39, 2731)
>>> print now
2008-12-13 14:09:39.002731
        ]]>
      </screen>
    </para>

    <para>
      Это достаточно просто и не требует наличия Django. Это просто
      код на языке Python. (Мы хотели бы подчеркнуть, что вы должны
      знать различия между <quote>просто Python</quote> и кодом,
      который относится к Django. После того, как вы изучите Django,
      мы хотим, чтобы вы могли применить свои знания в других Python
      проектах, которые не обязательно бы использовали Django.)
    </para>

    <para>
      Для того, чтобы создать представление, которое отображает
      текущую дату и время, необходимо добавить вызов
      <function>datetime.datetime.now()</function> в представление и
      возвратить <classname>HttpResponse</classname>. Вот так это
      выглядит:
      <screen>
        <![CDATA[
from django.http import HttpResponse
import datetime

def current_datetime(request):
    now = datetime.datetime.now()
    html = "<html><body>It is now %s.</body></html>" % now
    return HttpResponse(html)
        ]]>
      </screen>
    </para>

    <para>
      Аналогично функции представления <function>hello</function>,
      данная функция должна располагаться в
      <filename>views.py</filename>. Следует отметить, что мы спрятали
      функцию <function>hello</function> из этого примера для
      краткости, но весь файл будет выглядеть так:
      <screen>
        <![CDATA[
from django.http import HttpResponse
import datetime

def hello(request):
    return HttpResponse("Hello world")

def current_datetime(request):
    now = datetime.datetime.now()
    html = "<html><body>It is now %s.</body></html>" % now
    return HttpResponse(html)
        ]]>
      </screen>
    </para>

    <para>
      (Начиная с этого места, мы больше не будем показывать предыдущий
      код в примерах, кроме моментов, когда это действительно
      необходимо. У вас будет возможность понять из контекста, какая
      часть кода новая, а какая - старая.)
    </para>

    <para>
      Пройдёмся по изменениям, которые мы сделали в
      <filename>views.py</filename> при создании представления
      <function>current_datetime</function>:

      <itemizedlist>
        <listitem>
          <para>
            Мы добавили <token>import datetime</token> в начало
            модуля, теперь мы можем работать с датами.
          </para>
        </listitem>

        <listitem>
          <para>
            Новая функция <function>current_datetime</function>
            возвращает текущую дату и время, в виде объекта
            <classname>datetime.datetime</classname>, и сохраняет его
            в локальной переменной <varname>now</varname>.
          </para>
        </listitem>

        <listitem>
          <para>
            Вторая строка кода внутри представления создаёт HTML
            отклик, используя возможности Python для форматирования
            строк. Элемент <token>%s</token> внутри строки является
            подстановкой, а знак процента после строки означает
            <quote>Замени <token>%s</token> в предыдущей строке на
            значение переменной <varname>now</varname>.</quote>
            Переменная <varname>now</varname> технически является
            объектом <classname>datetime.datetime</classname>, не
            строкой, но подстановка <token>%s</token> преобразовывает
            его в строковое представление, подобное <token>"2008-12-13
            14:09:39.002731"</token>. Всё это выражается в виде HTML
            строки <token>"<![CDATA[<html><body>It is now 2008-12-13
            14:09:39.002731.</body></html>]]>"</token>.
          </para>

          <para>
            (Да, наш HTML некорректен, но мы стараемся сделать наш
            пример простым и коротким.)
          </para>
        </listitem>

        <listitem>
          <para>
            Наконец, представление возвращает объект
            <classname>HttpResponse</classname>, который содержит
            сгенерированный отклик - точно так же, как и в
            случае с <function>hello</function>.
          </para>
        </listitem>
      </itemizedlist>
    </para>

    <para>
      После добавления новой функции в <filename>views.py</filename>,
      следует добавить шаблон в <filename>urls.py</filename>, чтобы
      указать Django какой именно URL должен обрабатываться с помощью
      этой функции представления. Подойдёт что-нибудь подобное
      <token>/time/</token>:
      <screen>
        <![CDATA[
from django.conf.urls.defaults import *
from mysite.views import hello, current_datetime

urlpatterns = patterns('',
    ('^hello/$', hello),
    ('^time/$', current_datetime),
)
        ]]>
      </screen>
    </para>

    <para>
      Здесь мы сделали два изменения. Сначала мы проимпортировли
      функцию <function>current_datetime</function> в начале
      модуля. Затем, и это самое главное, мы добавили шаблон URL
      <token>/time/</token>, ассоциированный с этим новым
      представлением.
    </para>

    <para>
      После всех этих действий можно запустить
      <token>runserver</token> и посетите <ulink
      url="http://127.0.0.1:8000/time/"/> с помощью браузера. Вы
      должны увидеть текущую дату и время.

      <note>
        <title>
          Временная зона в Django
        </title>

        <para>
          Время на вашем компьютере может отличаться на несколько
          часов. Всё потому, что Django обращает внимание на временные
          зоны, а по умолчанию Django настроен на зону
          <token>America/Chicago</token>. (Она должна быть установлена
          по-умолчанию, вот разработчики Django и выбрали в качестве
          таковой свою временную зону.) Если вы живёте не рядом с
          ними, укажите свою зону в
          <filename>settings.py</filename>. Обратите внимание на
          комментарий в этом файле, там указана ссылка с актуальным
          списком мировых временных зон.
        </para>
      </note>
    </para>

  </section>

  <section id="&BASEID;.loose-coupling">

    <title id="&BASEID;.loose-coupling.title">
      Схема URL и свободное связывание
    </title>

    <para>
      Настало время указать на ключевой момент схемы URL и Django в
      целом: принцип <emphasis>свободного
      связывания</emphasis>. Просто примем, что свободное связывание
      является неким подходом к разработке программного обеспечения,
      который отражает важность создания связываемых компонентов. Если
      два компонента кода свободно связаны, тогда изменения, сделанные
      в одном компоненте отразятся незначительно или совсем не
      отразятся на коде другого компонента.
    </para>

    <para>
      Схема URL Django является хорошим примером применения такого
      принципа на практике. В Django-приложении определения URL и
      функций представления, которые они вызывают связаны
      свободно. Следовательно, решение о том, какой URL должен
      соответствовать данной функции и реализация самой функции
      располагаются в двух разных местах. Это позволяет вам отключать
      один компонент приложения без влияния на остальные.
    </para>

    <para>
      Для примера рассмотрим наше представление
      <function>current_datetime</function>. Если нам потребуется
      изменить URL в приложении, скажем, переименовать его из
      <token>/time/</token> в <token>/current-time/</token>, нам
      достаточно будет сделать быстрое изменение в файле привязок, не
      беспокоясь о самом представлении. Аналогично, если нам
      потребуется изменить функцию представления - как-то
      изменить логику её работы - мы можем сделать это без
      внесения изменений в URL, к которому привязана данная функция.
    </para>

    <para>
      Продолжая, если нам потребуется разделить функционал данного
      представления между <emphasis>несколькими</emphasis> URL, мы
      сможем легко реализовать это, отредактировав схему URL, не внося
      изменений в код представления. В данном примере, наше
      представление <function>current_datetime</function> доступно по
      двум URL:
      <screen>
        <![CDATA[
urlpatterns = patterns('',
    ('^hello/$', hello),
    ('^time/$', current_datetime),
    ('^another-time-page/$', current_datetime),
)
        ]]>
      </screen>
    </para>

    <para>
      Схема URL и представления являются примером свободного
      связывания в действии. Мы продолжим рассматривать на примерах
      этот важный подход в течение всей книги.
    </para>

  </section>

  <section id="&BASEID;.third-view">

    <title id="&BASEID;.third-view.title">
      Ваше третье представление: Динамические URL
    </title>

    <para>
      В нашем представлении <function>current_datetime</function>
      содержимое страницы - текущая дата и время - были
      динамическими, но URL оставался статическим. В большинстве
      динамических web-приложений URL содержат параметры, которые
      влияют на генерацию страницы. Например, онлайн магазин может
      отображать книгу по её собственному URL, таким как
      <token>/books/243/</token> и <token>/books/81196/</token>.
    </para>

    <para>
      Давайте создадим третье представление, которое отображает
      текущую дату и время со смещением на указанное количество
      часов. Цель - реализовать функциональность, с помощью
      которой сайт будет по URL <token>/time/plus/1/</token> отдавать
      текущее время сдвинутое на час вперёд, а по URL
      <token>/time/plus/2/</token> - на два часа вперёд и так
      далее.
    </para>

    <para>
      Новичок может подумать, что потребуется создавать функцию
      представления для каждого смещения часа, что может выразится в
      следующей схеме URL:
      <screen>
        <![CDATA[
urlpatterns = patterns('',
    ('^time/$', current_datetime),
    ('^time/plus/1/$', one_hour_ahead),
    ('^time/plus/2/$', two_hours_ahead),
    ('^time/plus/3/$', three_hours_ahead),
    ('^time/plus/4/$', four_hours_ahead),
)
        ]]>
      </screen>
    </para>

    <para>
      Очевидно, это направление мысли является ущербным. Такой подход
      не только приведёт к избыточности функций представления, но и к
      тому, что приложение будет явно ограничено заранее заданным
      диапазоном смещений - один, два, три или четыре часа. Если
      мы решим создать страницу, которая отображает текущее время со
      смещением на <emphasis>пять</emphasis> часов вперёд, нам
      потребуется создать отдельное представление и внести
      дополнительную строчку в схему URL, продолжая создавать
      избыточность. Нам потребуется немного окунуться в теорию.

      <note>
        <title>
          Слово о красивых URL
        </title>

        <para>
          Если вы работали с другими платформами разработки
          web-приложения, такими как PHP или Java, вы можете подумать:
          <quote>Эй, давайте использовать параметр строки
          запроса!</quote> - что-нибудь аналогичное
          <token>/time/plus?hours=3</token>, в котором смещение будет
          указано через параметр <varname>hours</varname> в URL.
        </para>

        <para>
          Вы <emphasis>можете</emphasis> сделать так и с Django (и мы
          расскажем об этом в главе 7 FIXME), но Django пропагандирует
          философию использования красивых URL. URL
          <token>/time/plus/3/</token> гораздо яснее, проще, более
          читаемое, его проще сказать кому-нибудь вслух и ... просто
          проще, чем его оппонент. Красивые URL являются
          характеристикой качества web-приложения.
        </para>

        <para>
          Система схемы URL Django поощряет создание красивых URL,
          упрощая использование таких URL, в
          <emphasis>отличие</emphasis> от других.
        </para>
      </note>
    </para>

    <para>
      Как же мы должны спроектировать наше приложение для обработки
      соответствующих смещений времени? Ответ лежит в использовании
      <emphasis>шаблонов подстановки</emphasis>. Как мы упоминали
      ранее, шаблон URL является регулярным выражением. Следовательно,
      мы можем использовать шаблон <token>\d+</token> для выделения
      одной или более цифр:
      <screen>
        <![CDATA[
urlpatterns = patterns('',
    # ...
    (r'^time/plus/\d+/$', hours_ahead),
    # ...
)
        ]]>
      </screen>
    </para>

    <para>
      (Мы используем <token>#...</token>, чтобы показать, что здесь
      могут быть другие шаблоны, которые мы временно исключили из
      данного примера.)
    </para>

    <para>
      Новый шаблон схемы URL будет соответствовать любому URL,
      подобному <token>/time/plus/2/</token>,
      <token>/time/plus/25/</token> и даже
      <token>/time/plus/100000000000/</token>. Давайте ограничим
      смещение 99-ю часами. Это означает, что мы разрешаем только
      одно- или двухзначиные числа. На языке регулярных выражений это
      преобразовывается в <token>\d{1,2}</token>:
      <screen>
        <![CDATA[
(r'^time/plus/\d{1,2}/$', hours_ahead),
        ]]>
      </screen>

      <note>
        <para>
          При разработке web-приложения, важно всегда рассматривать
          наиболее диковинные варианты ввода данных и решать должно
          или нет приложение обрабатывать такой ввод. Мы ограничили
          здесь возможности ввода смещения 99-ю часами.
        </para>
      </note>
    </para>

    <para>
      Ещё одной важной деталью, которую мы ввели здесь, является
      символ <token>r</token> в начале строки регулярного
      выражения. Он указывает Python, что строка является
      <quote>сырой</quote> - в её содержимом не следует
      интерпретировать обратные слеши. В обычной строке Python,
      обратные слеши используются для экранирования особых символов,
      например, <token>\n</token> - односимвольная строка. Если
      предварить её символом <token>r</token>, сделав её
      <quote>сырой</quote>, Python не будет выполнять экранирование
      - таким образом, <token>r'\n'</token> станет
      двухсимвольной строкой, содержащей обратный слеш и символ
      <token>n</token>. Существует естественная коллизия между
      обычными обратными слешами и используемыми в регулярных
      выражениях. Крайне рекомендуется всегда использовать сырые
      строки при определении регулярных выражений в Python. С этого
      момента следует считать, что все шаблоны URL, показанные в этой
      книге, будут представлены сырыми строками.
    </para>

    <para>
      После применения символов подстановки в URL необходим способ
      передачи выделенных подстановкой данных в функцию представления,
      это позволит нам использовать единственную функцию представления
      для любого разрешённого смещения часов. Мы осуществляем это с
      помощью установки скобок вокруг интересующей нас части шаблона
      URL. В рамках нашего примера, это будет любое число в URL, таким
      образом, надо расположить скобки вокруг выражения
      <token>\d{1,2}</token>, например:
      <screen>
        <![CDATA[
(r'^time/plus/(\d{1,2})/$', hours_ahead),
        ]]>
      </screen>
    </para>

    <para>
      Если у вас уже есть опыт работы с регулярными выражениями, то
      вам будет легко. Мы используем скобки для
      <emphasis>выделения</emphasis> данных из совпавшего текста.
    </para>

    <para>
      В итоге схема URL будет выглядеть так:
      <screen>
        <![CDATA[
from django.conf.urls.defaults import *
from mysite.views import hello, current_datetime, hours_ahead

urlpatterns = patterns('',
    (r'^hello/$', hello),
    (r'^time/$', current_datetime),
    (r'^time/plus/(\d{1,2})/$', hours_ahead),
)
        ]]>
      </screen>
    </para>

    <para>
      Теперь напишем представление <function>hours_ahead</function>.

      <note>
        <title>
          Порядок разработки
        </title>

        <para>
          В данном примере мы сначала создали шаблон URL, а затем
          представление. Но в предыдущих примерах, мы сначала
          создавали представление, а затем - шаблон URL. Какой
          подход лучше?
        </para>

        <para>
          Хорошо, каждый разработчик уникален.
        </para>

        <para>
          Если вам комфортно видеть весь проект целиком, может быть
          вам будет проще создать схему URL для всего функционала
          сайта за один раз, в начале проекта, а затем реализовать
          каждую функцию представления. Такой подход имеет
          преимущество, так как предоставляет ясный список работ и, по
          сути, определяет требования к параметрам функций
          представления, которые вам потребуется реализовать.
        </para>

        <para>
          Если вам комфортно разрабатывать проект, начиная с небольших
          компонентов, может быть вы предпочтёте сначала реализовать
          представления, а затем ассоциировать их с URL. Такой подход
          тоже имеет право на жизнь.
        </para>

        <para>
          В конце концов, не важно какой из подходов лучше или
          хуже. Они оба правильные.
        </para>
      </note>
    </para>

    <para>
      Представление <function>hours_ahead</function> очень похоже на
      представление <function>current_datetime</function>, которое мы
      написали ранее, с одним только отличием: оно принимает
      дополнительный аргумент - количество часов смещения. Вот
      его код:
      <screen>
        <![CDATA[
from django.http import Http404, HttpResponse
import datetime

def hours_ahead(request, offset):
    try:
        offset = int(offset)
    except ValueError:
        raise Http404()
    dt = datetime.datetime.now() + datetime.timedelta(hours=offset)
    html = "<html><body>In %s hour(s), it will be %s.</body></html>" % (offset, dt)
    return HttpResponse(html)
        ]]>
      </screen>
    </para>

    <para>
      Рассмотрим каждую строчку этого кода:

      <itemizedlist>
        <listitem>
          <para>
            Функция представления, <function>hours_ahead</function>,
            принимает <emphasis>два параметра</emphasis>:
            <varname>request</varname> и <varname>offset</varname>.

            <itemizedlist>
              <listitem>
                <para>
                  Параметр <varname>request</varname> является
                  объектом <classname>HttpRequest</classname>,
                  аналогичным используемому в представлениях
                  <function>hello</function> и
                  <function>current_datetime</function>. Мы повторим
                  ещё раз: каждое представление
                  <emphasis>всегда</emphasis> принимает объект
                  <classname>HttpRequest</classname> в качестве
                  первого аргумента.
                </para>
              </listitem>

              <listitem>
                <para>
                  Параметр <varname>offset</varname> является строкой,
                  выделенной скобками в шаблоне URL. Например, если
                  запрошенный URL был <token>/time/plus/3/</token>,
                  тогда <varname>offset</varname> будет содержать
                  строку <token>'3'</token>. Если
                  <token>/time/plus/21/</token> - строка
                  <token>'21'</token>. Следует отметить, что
                  выделенные значения всегда будут
                  <emphasis>строками</emphasis>, не целыми, даже если
                  строка составлена только из цифр.
                </para>

                <para>
                  (Технически, захваченные значения всегда будут
                  <emphasis>объектами
                  <classname>Unicode</classname></emphasis>, а не
                  простыми строками Python, но пока об этом
                  беспокоиться не следует.)
                </para>

                <para>
                  Мы решили назвать данный параметр
                  <varname>offset</varname>, но вы можете дать ему
                  любое другое имя, главное, чтобы оно соответствовало
                  требованиям языка Python для идентификаторов. Имя
                  переменной само по себе ничего не означает. Имеет
                  значение только то, что переменная является вторым
                  аргументом функции, после
                  <varname>request</varname>. (Также можно
                  использовать ключевые параметры в схеме URL вместо
                  позиционных. Мы расскажем об этом в главе 8 FIXME.)
                </para>
              </listitem>
            </itemizedlist>

          </para>
        </listitem>

        <listitem>
          <para>
            Первое, что мы делаем в функции - вызываем
            <function>int()</function> для
            <varname>offset</varname>. Данная функция преобразовывает
            строковое значение в целое.
          </para>

          <para>
            Следует отметить, что Python вызывет исключение
            <classname>ValueError</classname>, если в процессе вызова
            <function>int()</function> данная функция не сможет
            осуществить конвертацию, например, для строки
            <token>'foo'</token>. В данном примере, если мы получим
            <classname>ValueError</classname>, мы вызовем исключение
            <classname>django.http.Http404</classname>, которое, как
            вы можете представить, возвратит страницу с ошибкой 404
            - <quote>Страница не найдена</quote>
          </para>

          <para>
            Проницательному читателю будет интересно: как мы сможем
            попасть в ветку с <classname>ValueError</classname>,
            учитывая то, что регулярное выражение в нашем шаблоне
            - <token>(\d{1,2})</token> - принимает только
            цифры и, следовательно, <varname>offset</varname> всегда
            будет состоять из строки цифр? Ответ заключается в том,
            что мы и не рассчитываем на это, так как шаблон URL
            предоставляет простой, но достаточный уровень проверки,
            <emphasis>но</emphasis> мы попрежнему проверяем значение
            на случай, если данная функция представления будет вызвана
            каким-либо другим способом. Это хороший подход -
            реализация функций представления так, как будто им в
            параметрах может передаваться всё что угодно. Помните про
            свободное связывание?
          </para>
        </listitem>

        <listitem>
          <para>
            На следующей строке функции мы вычисляем текущую дату и
            время, а затем добавляем соответствующее число к часам. Мы
            уже встречались с
            <function>datetime.datetime.now()</function> в
            представлении
            <function>current_datetime</function>. Разница лишь в том,
            что здесь мы выполняем арифметические операции, создав
            объект <classname>datetime.timedelta</classname> и
            прибавив его к объекту
            <classname>datetime.datetime</classname>. Результат
            операции сохраняется в переменной <varname>dt</varname>.
          </para>

          <para>
            Данная строка также показывает почему мы вызываем
            <function>int()</function> для <varname>offset</varname>
            - функция <function>datetime.timedelta</function>
            требует, чтобы параметр <varname>hours</varname> содержал
            целое число.
          </para>
        </listitem>

        <listitem>
          <para>
            Затем мы создаём HTML документ для данного представления,
            аналогично тому, как это делалось в представлении
            <function>current_datetime</function>. Есть небольшое
            отличие в этой строке, от предыдущей - здесь
            используется строка форматирования с
            <emphasis>двумя</emphasis> подстановками, а не
            одной. Следовательно, строка содержит две подстановки
            <token>%s</token> и кортеж, содержащий значения:
            <token>(offset, dt)</token>..
          </para>
        </listitem>

        <listitem>
          <para>
            Наконец, мы возвращаем
            <classname>HttpResponse</classname>. Вот и всё.
          </para>
        </listitem>
      </itemizedlist>
    </para>

    <para>
      Реализовав данную функцию представления и привязав её к URL,
      запустите тестовый сервер Django (если он ещё не запущен) и
      посетите <ulink url="http://127.0.0.1:8000/time/plus/3/"/> для
      проверки работы функции. Затем попробуйте <ulink
      url="http://127.0.0.1:8000/time/plus/5/"/>. Затем <ulink
      url="http://127.0.0.1:8000/time/plus/24/"/>. Наконец, посетите
      <ulink url="http://127.0.0.1:8000/time/plus/100/"/>, чтобы
      проверить, что шаблон URL принимает только одно- или
      двухсимвольные числа. Django должна отобразить <quote>Страница
      не найдена</quote> в этом случае. <ulink
      url="http://127.0.0.1:8000/time/plus/"/>
      (<emphasis>без</emphasis> указания часов) также должен вызвать
      ошибку 404.
    </para>

  </section>

  <section id="&BASEID;.pretty-error">

    <title id="&BASEID;.pretty-error.title">
      Красивые страницы об ошибке
    </title>

    <para>
      Восхититесь созданным вами web-приложением, а теперь давайте
      сломаем его. Умышленно внесём ошибку в код представления
      <function>hours_ahead</function>, закомментировав строки
      <token>offset = int(offset)</token>:
      <screen>
        <![CDATA[
def hours_ahead(request, offset):
    # try:
    #     offset = int(offset)
    # except ValueError:
    #     raise Http404()
    dt = datetime.datetime.now() + datetime.timedelta(hours=offset)
    html = "<html><body>In %s hour(s), it will be %s.</body></html>" % (offset, dt)
    return HttpResponse(html)
        ]]>
      </screen>
    </para>

    <para>
      Запустите тестовый сервер и перейдите по ссылке <ulink
      url="http://127.0.0.1:8000/time/plus/3/"/>. Вы увидите страницу
      с ошибкой, которая будет содержать значительный объём
      информации, включая <classname>TypeError</classname> сообщение
      на самом верху:
      <screen>
        <![CDATA[
"unsupported type for timedelta hours component: unicode"
        ]]>
      </screen>
    </para>

    <para>
      Что же случилось? Как мы говорили функция
      <function>datetime.timedelta</function> ожидает, что параметр
      <varname>hours</varname> является целым числом, а мы
      закомментировали кусок кода, который выполняет это
      преобразование для <varname>offset</varname>. Это привело к
      вызову <classname>TypeError</classname> функцией
      <function>datetime.timedelta</function>. Это типичная ошибка.
    </para>

    <para>
      Целью данного примера было продемонстрировать как Django
      отображает страницы с ошибкой. Потратьте немного времени на
      изучение этой страницы и вы увидите, как много информации она
      предоставляет.
    </para>

    <para>
      Отметим следующее:
      <itemizedlist>
        <listitem>
          <para>
            Наверху страницы отображается ключевая информации об
            исключении: тип исключения; любой параметр, вызвавший его
            (в данном случае это <token>"unsupported type"</token>);
            имя файла, в котором произошло исключение и номер
            соответствующей строки в файле.
          </para>
        </listitem>

        <listitem>
          <para>
            Чуть ниже отображается полный трейс для данного
            исключения. Он аналогичен стандартному трейсу, который вы
            получаете при работе с интерпретатором командной строки,
            только этот более интерактивен. Для каждого уровня (кадра)
            стека Django отображает имя файла и имя функции/метода,
            номер строки и исходный код данной строки.
          </para>

          <para>
            Если кликнуть на строку с исходным кодом, то вы увидите
            несколько строк выше и ниже данной строки, это даст вам
            контекст ошибки.
          </para>

          <para>
            Кликните на <quote>Local vars</quote> под любым кадром
            стека для того, чтобы получить таблицу всех локальных
            переменных и их значения именно в этой точке кода. Эта
            отладочная информация бывает очень полезна.
          </para>
        </listitem>

        <listitem>
          <para>
            Обратите внимание на текст <quote>Switch to copy-and-paste
            view</quote> под заголовком
            <quote>Traceback</quote>. Нажмите на эти слова и трейс
            переключится в альтернативный вид, который может быть
            легко скопирован. Используйте эту возможность когда вам
            необходимо поделиться информацией об ошибке с другими
            разработчиками для получения технической поддержки -
            например с людьми с канала
            <token>djangobook@conference.jabber.ru</token> или в
            списке рассылки.
          </para>

          <para>
            Ниже расположенная кнопка <guibutton>Share this traceback
            on a public Web site</guibutton> сделает эту работу за
            вас. Она отправляет информацию об ошибке на сервис <ulink
            url="http://www.dpaste.com/"/>, вы получаете точный URL с
            текстом ошибки и можете передавать его другим
            разработчикам.
          </para>
        </listitem>

        <listitem>
          <para>
            Секция <quote>Request information</quote> содержит
            информацию о пришедшем web-запросе, который вызвал ошибку:
            GET и POST информация, значения cookie и такая мета
            информация, как CGI заголовки.
          </para>

          <para>
            Под секцией <quote>Request information</quote> расположена
            секция <quote>Settings</quote> со списком всех настроек
            для данного проекта. (Мы уже упоминали
            <token>ROOT_URLCONF</token> и мы покажем различные
            параметры в течение книги.)
          </para>
        </listitem>
      </itemizedlist>
    </para>

    <para>
      Страница с ошибкой имеет возможность отображать ещё больше
      информации в особых случаях, например, в случаях ошибки в
      синтаксисе шаблона. Мы рассмотрим это позже, когда будем
      обсуждать шаблонную систему Django. А сейчас, раскомментируйте
      строки представления <function>hours_ahead</function>, чтобы она
      смогла работать правильно.
    </para>

    <para>
      Вы являетесь разработчиком, которому нравится производить
      отладку кода с помощью оператора <token>print</token>? Вы можете
      использовать для этого страницу ошибки Django - без всяких
      <token>print</token>. Вставьте на время в любой точке вашего
      представления оператор <token>assert False</token> - это
      вызовет отображение ошибки. Затем, вы можете просмотреть
      локальные переменные и состояние программ. Ниже дан пример
      использования этого подхода в представлении
      <function>hours_ahead</function>:
      <screen>
        <![CDATA[
def hours_ahead(request, offset):
    try:
        offset = int(offset)
    except ValueError:
        raise Http404()
    dt = datetime.datetime.now() + datetime.timedelta(hours=offset)
    assert False
    html = "<html><body>In %s hour(s), it will be %s.</body></html>" % (offset, dt)
    return HttpResponse(html)
        ]]>
      </screen>
    </para>

    <para>
      Очевидно, что большая часть данной информации не стоит
      показывать всем - она рассказывает о вашем коде и
      настройках Django - будет глупо отображать её всему
      Internet. Какой-нибудь отрицательный персонаж может
      воспользоваться ей для изучения вашего web-приложения и
      осуществления своих зловредных планов. По этой причине Django
      отображает страницу с ошибкой только когда находится в режиме
      отладки. Мы объясним позже как деактивировать отладочный режим в
      главе <quote><xref linkend="djangobook.chap12"
      endterm="djangobook.chap12.title"/></quote>. Просто запомните,
      что после создания проект находится в режиме отладки.
    </para>

  </section>

</chapter>
